# GitLab CI Configuration for Go Projects with Private Modules
# =============================================================
#
# This template configures Go builds to access private GitLab modules
# from the tinyland namespace.
#
# Add this to your .gitlab-ci.yml:
#
# include:
#   - local: '.gitlab/ci/go-private-modules.yml'

# Variables for Go private module access
variables:
  # Configure Go to treat tinyland modules as private
  GOPRIVATE: "gitlab.com/tinyland/*"
  GONOSUMDB: "gitlab.com/tinyland/*"
  GONOPROXY: "gitlab.com/tinyland/*"

  # Use Go module proxy for public modules
  GOPROXY: "https://proxy.golang.org,direct"
  
  # Go version alignment
  GO_VERSION: "1.25"

# Before script template for Go jobs needing private module access
.go_private_modules_setup:
  before_script:
    - |
      echo "Setting up Go private module access..."

      # Configure Git to use GitLab CI token for private repos
      git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/".insteadOf "https://gitlab.com/"

      # Alternative: Use project/group access token if CI_JOB_TOKEN doesn't have access
      # Uncomment and set GITLAB_PRIVATE_TOKEN in CI/CD variables:
      # git config --global url."https://oauth2:${GITLAB_PRIVATE_TOKEN}@gitlab.com/".insteadOf "https://gitlab.com/"

      # Configure netrc for Go module downloads
      cat > ~/.netrc <<EOF
      machine gitlab.com
      login gitlab-ci-token
      password ${CI_JOB_TOKEN}
      EOF
      chmod 600 ~/.netrc

      # Verify Go configuration
      echo "Go environment:"
      go env GOPRIVATE
      go env GONOSUMDB
      go env GONOPROXY

      echo "Private module access configured"

# Build job with private module support
build-with-private-modules:
  extends: .go_private_modules_setup
  stage: build
  image: golang:1.25
  script:
    - echo "Downloading dependencies..."
    - go mod download
    - echo "Building..."
    - go build -v ./...
  artifacts:
    paths:
      - crush  # or fantasy, or other binary name
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Test job with private module support
test-with-private-modules:
  extends: .go_private_modules_setup
  stage: test
  image: golang:1.25
  script:
    - echo "Downloading dependencies..."
    - go mod download
    - echo "Running tests..."
    - mkdir -p test-results
    - go test -v -race -coverprofile=test-results/coverage.txt -covermode=atomic ./... > test-results/test-output.log 2>&1 || (cat test-results/test-output.log && exit 1)
    - echo "Test results saved to test-results/test-output.log"
  coverage: '/coverage: \d+.\d+% of statements/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: test-results/coverage.txt
    paths:
      - test-results/
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# RenovateBot-compatible build job
# This job is triggered by RenovateBot MRs to validate dependency updates
renovate-build:
  extends: .go_private_modules_setup
  stage: build
  image: golang:1.25
  script:
    - echo "RenovateBot dependency update validation"
    - go mod download
    - go mod tidy
    - go build -v ./...
    - go test -v ./...
  rules:
    - if: '$CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^renovate\//'
      when: always

# Verify go.mod and go.sum are in sync
go-mod-verify:
  extends: .go_private_modules_setup
  stage: test
  image: golang:1.25
  script:
    - go mod download
    - go mod verify
    - go mod tidy
    - |
      if [ -n "$(git status --porcelain go.mod go.sum)" ]; then
        echo "go.mod or go.sum changed after go mod tidy:"
        git diff go.mod go.sum
        
        # Check if this is a dependency update (expected change)
        if git log --oneline -1 | grep -E "(update|upgrade|bump|fix.*deps)"; then
          echo "Dependency update detected - go.mod/go.sum changes are expected"
          echo "Consider committing these changes if they look correct:"
          echo "  git add go.mod go.sum"
          echo "  git commit -m 'chore: update go.sum after dependency changes'"
          exit 0
        else
          echo "Error: go.mod or go.sum is out of sync without dependency update"
          echo "Please run 'go mod tidy' locally and commit the changes"
          exit 1
        fi
      fi
    - echo "go.mod and go.sum are in sync"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - go.mod
        - go.sum

# Security scanning with private module support
gosec-scan:
  extends: .go_private_modules_setup
  stage: test
  image: golang:1.25
  before_script:
    - |
      echo "Setting up Go private module access..."
      git config --global url."https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/".insteadOf "https://gitlab.com/"
      cat > ~/.netrc <<EOF
      machine gitlab.com
      login gitlab-ci-token
      password ${CI_JOB_TOKEN}
      EOF
      chmod 600 ~/.netrc
      go env GOPRIVATE
      go env GONOSUMDB
      go env GONOPROXY
    # Install golangci-lint v1 (matching local setup)
    - go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.64.8
    - export PATH=$PATH:$(go env GOPATH)/bin
  script:
    - mkdir -p test-results
    - golangci-lint run --no-config --enable=gosec,misspell,errcheck,gosimple --timeout=10m > test-results/lint.log 2>&1; echo "Lint completed with findings - see test-results/lint.log"
    - echo "Lint results saved to test-results/lint.log"
  artifacts:
    reports:
      junit: golangci-lint-report.xml
    paths:
      - golangci-lint-report.xml
      - test-results/
    expire_in: 1 week
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Example: Using group/project access token instead of CI_JOB_TOKEN
# -------------------------------------------------------------------
# If CI_JOB_TOKEN doesn't have access to your private modules, use a
# project/group access token:
#
# 1. Create token at: Settings > Access Tokens
# 2. Scopes: read_repository, read_api
# 3. Add to CI/CD variables: GITLAB_PRIVATE_TOKEN
# 4. Uncomment the alternative git config line in .go_private_modules_setup

# Example: SSH-based authentication
# ----------------------------------
# If you prefer SSH over HTTPS:
#
# 1. Add deploy key to private module repos
# 2. Add private key to CI/CD variables: SSH_PRIVATE_KEY
# 3. Use this before_script instead:
#
# .go_private_modules_ssh_setup:
#   before_script:
#     - |
#       eval $(ssh-agent -s)
#       echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
#       mkdir -p ~/.ssh
#       chmod 700 ~/.ssh
#       ssh-keyscan gitlab.com >> ~/.ssh/known_hosts
#       git config --global url."git@gitlab.com:".insteadOf "https://gitlab.com/"
